1. Khái niệm cơ bản
- Dữ liệu cơ sở là dữ liệu cơ bản ban đầu, cần cho bài toán
- Dữ liệu thứ cấp là dữ liệu có thể suy ratừ dữ liệu cơ sở
- Cấu trúc dữ liệu là kết hợp dữ liệu cơ sở theo 1 cách nào đó (mảng/cây/đồ thị…) nhằm liên kết thành 1 thể thống nhất thuận tiện cho xử lý
- Cấu trúc lưu trữ là phương thức biểu diễn 1 cấu trúc dữ liệu trong bộ nhớ
- Giải thuật ~ thuật toán ~ cách giải là quy tắc chặt chẽ (hiểu 1 nghĩa) theo trình tự trên đối tượng cụ thể (1 dạng nhất định) để giải quyết 1 vấn đề
  + Cấu trúc điều khiển
    -- Tuần tự: Mỗi bước thực hiện đúng 1 lần theo trình tự
    -- Chọn lọc: Chọn thực hiện 1 trong nhiều thao tác
    -- Chu trình: Có bước được thực hiện lặp lại
  + Phương pháp biểu diễn
    -- Bằng lời: Nắm tư tưởng chủ đạo, trừu tượng cao
    -- Bằng sơ đồ khối: Cái nhìn tổng quát cấu trúc
    -- Bằng ngôn ngữ lập trình: Biểu diễn ngắn gọn
- CHƯƠNG TRÌNH = CẤU TRÚC DỮ LIỆU + GIẢI THUẬT
- Đệ quy → Đối tượng được định nghĩa qua chính bản thân, bao hàm chính nó như bộ phận cấu thành
  + Phần neo: Tác động đặc tả cho 1 tham số (trường hợp dừng)
  + Phần đệ quy: Tác động cần thực hiện cho giá trị hiện thời của tham số có giá trị đã được định nghĩa trước đó (tự gọi hàm)

2. Độ phức tạp của thuật toán
- Hiệu suất
  + Bộ nhớ
  + Thời gian (Kích thước đầu vào ~ quan trọng, kiểu lệnh, tốc độ máy, chất lượng chương trình dịch)
- T(n) là hàm số phép tính mà giải thuật thực hiện
  → BigO ~ O(n) là thời gian thực hiện lâu nhất của thuật toán với mọi kích thước đầu vào

3. Module hóa
- Module hóa là chia bài toán lớn thành các bài nhỏ hơn, ngày càng cụ thể chi tiết
- Phân rã module là tư tưởng chính tạo nên phương hướng quan trọng (lập trình cấu trúc)
- Phương pháp
  + Top Down: Xác định vấn đề bao quát, phân chia nhiệm vụ thành module con
  + Bottom Up: Gộp các module cùng chức năng, thiết kế thêm cho phong phú đầy đủ

4. Kĩ thuật giải thuật
- Chia để trị: Chia thành các bài toán con có kích thước nhỏ hơn, giải các bài con rồi tổng hợp kết quả
  + Quan trọng nhất
  + Gồm: Phân tích thành bài toán cơ sở và Tổng hợp kết quả
- Quy hoạch động: Tạo bảng lưu tất cả các kết quả của bài toán con, khi cần thì lấy kết quả từ bảng mà không cần tính lại
- Lựa chọn thành phần ~ Tham ăn: Lựa chọn các thành phần tốt, tối ưu trước, các thành phần không tốt chọn sau
- Quay lui: Phân tích cho tới cả điểm dừng, khi không ra kết quả thì quay lại hoặc đi hướng khác
  + Nghịch đảo Ba Lan
  + Cắt tỉa Alpha-Beta

5. Mảng
- Mảng là tập hợp có thứ tự, số lượng phần tử xác định, truy cập cùng tên
- Mảng 1 chiều là tập hợp tuần tự phần tử cùng kiểu dữ liệu, lưu trữ trong dãy ô nhớ liên tục
  + Địa chỉ = Base + (i-1)
  + Phép toán
    -- Tạo
    -- Sắp xếp
    -- Tìm kiếm
    -- Tính toán: tbinh = cộng → chia, phsai = cộng bp → chia, dolech = bình phương
- Mảng 2 chiều (m x n ~ m dòng và n cột) là nhiều mảng 1 chiều đứng cạnh nhau
  + Lưu trữ
    -- Ưu tiên dòng: P(i,j) = Base + (i−1).n.k + (j−1).k
    -- Ưu tiên cột: P(i,j) = Base + (i−1).k + (j−1).m.k
  + Phép toán: Tạo, tìm, cộng, nhân 2 chiều với 1 chiều, nhân 2 chiều

6. Danh sách
- Là tập hợp nhiều phần tử có tính chất cấu trúc thứ tự giữa các phần tử với nhau: Nếu biết được phần tử thứ i thì sẽ biết được vị trí của phần tử thứ i+1
  + Các phần tử có thể nằm rải rác trong bộ nhớ, không liền kề nhau
  + Key là thông tin tìm kiếm
  + Kết quả tìm kiếm là vị trí
- Phép toán: Tìm, thêm, xóa, thay thế phần tử, ghép, tách, sắp xếp
  
  a. Stack = ngăn xếp (LIFO)
- Là kiểu danh sách tuyến tính mà việc thêm hay bỏ chỉ thực hiện ở 1 đầu đỉnh (Top)
  → Danh sách hạn chế
- Rỗng → Top=0, tràn → Top=n, thêm → Top+=1, xóa → Top-=1
- Lưu trữ = mảng

  b. Queue = hàng đợi (FIFO)
- Là kiểu danh sách tuyến tính mà việc thêm thực hiện ở lối sau (Rear) và xóa thực hiện ở lối trước (Front)
- Rỗng → Front = Rear
- Lưu trữ = vector
  + Theo mảng tuyến tính: Mặc định Front = Rear = 0 → Sẽ chạy lung tung trong bộ nhớ (Không tối ưu)
    -- Thêm: Rear = Rear + 1
    -- Xóa: Front = Front + 1
  + Theo nối vòng: Liền sau phần tử cuối = quay về phần tử đầu
    -- Thêm: Rear = (Rear+1) % Size
    -- Xóa: Front = (Front+1) % Size

  c. Danh sách liên kết đơn
- Mỗi phần tử lưu trữ trong 1 node, mỗi node gồm 1 số từ máy liên tiếp nhau, có thể nằm rải rác trong bộ nhớ
- Node = Data + Liên kết trỏ phần tử sau
- Phù hợp cho danh sách nhiều biến động >< Tìm kiếm sẽ lâu vì tìm tuần tự

  d. Danh sách liên kết đôi
- Các phần tử có 2 vùng liên kết
- Lptr của L và Rptr của R là Nil

7. Cấu trúc phi tuyến
  a. Cây
- Là tập hợp hữu hạn node có quan hệ phân cấp xuất phát từ node gốc (Root = mức 1)
- Cây nhị phân
  + Mỗi node chỉ có tối đa 2 node con
  -- Số node tối đa ở mức i = 2 ^ (i-1) 
  -- Số node tối đa trên cây có chiều cao h = 2^h - 1
  + Lưu trữ
  -- Bằng mảng
      → Node đánh số từ trái sang, từ trên xuống → Node con của i là 2i và 2i + 1
      → Tốn bộ nhớ, giải thuật không hiệu quả
  -- Bằng danh sách liên kết đôi: Trường dữ liệu, trỏ LChild tới con trái, trỏ RChild tới con phải
- Quét cây nhị phân: 6 cách nhưng phổ biến 3 cách
  + LNR (trung tự)
  + NLR (tiền tự)
  + LRN (hậu tự)
- Cây nhị phân tìm kiếm → Mỗi node thỏa mãn: node trái nhỏ hơn, node phải lớn hơn
- Cây nhị phân cân đối AVL
  + Chiều cao 2 cây con tương ứng với mỗi node chênh nhau 1 đơn vị
    → Cây nhị phân đầy đủ là cây AVL
  + Hệ số cân đối
    -- 00 → 2 cây con cùng chiều cao
    -- 01 → Cây con phải cao hơn
    -- 10 → Cây con trái cao hơn

  b. Đồ thị
- Đồ thị có hướng
  + Tập hợp hữu hạn phần tử node hay đỉnh, cùng tập hợp hữu hạn cạnh có hướng nối các đỉnh
  + Biểu diễn
    -- Ma trận kề → Tốn nhiều bộ nhớ
        Ma trận vuông bậc n
        Hàng i cột j = đường từ i đến j
    -- Danh sách kề
        Mảng con trỏ, mỗi con trỏ cho 1 node trong đồ thị
        Mỗi phần tử trỏ đến đầu danh sách liên kết của node kề (dữ liệu node + liên kết chỉ node sau)
- Đồ thị vô hướng
  + Tập hợp hữu hạn phần tử node hay đỉnh, cùng tập hợp hữu hạn cạnh nối các đỉnh
  + Biểu diễn
    -- Ma trận kề = ma trận đối xứng → Cho hàng i cột j sẽ biết đường từ j đến i 
    -- Danh sách kề → Thông tin lưu trữ bị thừa
    -- Danh sách cạnh: Cạnh biểu diễn bằng 1 nhóm 4 ô (2 ô trên là node nối bởi cạnh, 2 ô dưới chỉ đến cạnh khác)
- Cây là trường hợp đặc biệt của đồ thị ~ Đồ thị có hướng
  → Quét cây
  + Ưu tiên chiều rộng (BFS) = Thăm các node lần lượt theo mức từ trên xuống
  + Ưu tiên chiều sâu (DFS) = Thăm từng node con theo chiều sâu từ trái qua, từ trên xuống

8. Sắp xếp
- Đánh giá giải thuật
  + Vùng nhớ nhỏ = Sử dụng hữu hiệu vùng nhớ phần tử + Hạn chế sử dụng vùng nhớ tạm
  + Thời gian nhanh = Số lần so sánh (C) + Số lần đổi chỗ (M)
- Phân loại = Xen vào + Chọn lựa + Đổi chỗ
- Sắp xếp theo khóa
  + Trường khóa là trường mà ta muốn sắp xếp theo
  + Bảng khóa là bảng phụ chỉ chứa trường khóa và con trỏ tới bản ghi tương ứng trong bảng gốc
    → Sắp xếp trong bảng khóa, truy nhập bản ghi theo thứ tự qua con trỏ → Tiết kiệm bộ nhớ

- Nổi bọt (cải tiến thành Shaker) ~ So sánh liên tiếp → Chậm nhất 

- Chọn → Pp trực tiếp tốt nhất

- Nhanh → Nhanh và tốt nhất
  + Phần tử biên

- Đếm
  + Đếm số phần tử có khóa nhỏ hơn hoặc bằng A[i]
    → Có m phần tử thỏa mãn thì vị trí A[i] là m+1
  + Phân tích: C=n(n-1)/2 và M=n
- Chèn
  + Phần tử cầm canh
- Trộn
  + hcujc

9. Tìm kiếm
- Khóa tìm kiếm (đối trị) là giá trị cần tìm kiếm ~ X
- Tuần tự (đơn giản, cổ điển)
  + Lần lượt so sánh khóa với X cho đến khi tìm được hoặc hết bảng
  + Độ phức tạp = O(n)
- Nhị phân (thông dụng)
  + Sắp xếp, lấy khóa [(k+m)/2] so sánh với X, xác định đoạn mới cho đến khi tìm được hoặc còn 1 phần tử
    -- Ban đầu k=1, m=n
    -- Khóa < X → k=i, m=n
    -- Khóa > X → k=1, m=i-1
  + Độ phức tạp = O(log(2)n)
- Dựa vào giá trị khóa: Bằng quy tắc, biến đổi bản ghi thành địa chỉ tương đối để lưu trữ và tìm kiếm
  → Hàm băm
