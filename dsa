    1. CƠ BẢN
- Dữ liệu cơ sở là dữ liệu cơ bản ban đầu, cần cho bài toán
- Dữ liệu thứ cấp là dữ liệu có thể suy ratừ dữ liệu cơ sở
- Cấu trúc dữ liệu là kết hợp dữ liệu cơ sở theo 1 cách nào đó (mảng/cây/đồ thị…) nhằm liên kết thành 1 thể thống nhất thuận tiện cho xử lý
- Cấu trúc lưu trữ là phương thức biểu diễn 1 cấu trúc dữ liệu trong bộ nhớ
- Giải thuật ~ thuật toán ~ cách giải là quy tắc chặt chẽ (hiểu 1 nghĩa) theo trình tự trên đối tượng cụ thể (1 dạng nhất định) để giải quyết 1 vấn đề
  + Tính chất = Rõ ràng, Xác định, Chính xác, Khách quan, Phổ dụng, Kết thúc, Đơn giản
  + Cấu trúc điều khiển
    -- Tuần tự: Mỗi bước thực hiện đúng 1 lần theo trình tự
    -- Chọn lọc ~ Điều kiện: Chọn thực hiện 1 trong nhiều thao tác
    -- Chu trình: Có bước được thực hiện lặp lại
  + Phương pháp biểu diễn
    -- Bằng lời: Nắm tư tưởng chủ đạo, trừu tượng cao
    -- Bằng sơ đồ khối: Cái nhìn tổng quát cấu trúc
    -- Bằng ngôn ngữ lập trình: Biểu diễn ngắn gọn
- CHƯƠNG TRÌNH = CẤU TRÚC DỮ LIỆU + GIẢI THUẬT
- Đệ quy → Đối tượng được định nghĩa qua chính bản thân, bao hàm chính nó như bộ phận cấu thành
  + Phần neo: Tác động đặc tả cho 1 tham số (trường hợp dừng)
  + Phần đệ quy: Tác động cần thực hiện cho giá trị hiện thời của tham số có giá trị đã được định nghĩa trước đó (tự gọi hàm)

    2. ĐỘ PHỨC TẠP
- Hiệu suất
  + Bộ nhớ
  + Thời gian (Kích thước đầu vào ~ quan trọng, kiểu lệnh, tốc độ máy, chất lượng chương trình dịch)
- T(n) là hàm số phép tính mà giải thuật thực hiện
  → BigO ~ O(n) là thời gian thực hiện lâu nhất của thuật toán với mọi kích thước đầu vào

    3. MODULE HÓA
- Module hóa là chia bài toán lớn thành các bài nhỏ hơn, ngày càng cụ thể chi tiết
- Phân rã module là tư tưởng chính tạo nên phương hướng quan trọng (lập trình cấu trúc)
- Phương pháp
  + Top Down: Xác định vấn đề bao quát, phân chia nhiệm vụ thành module con
  + Bottom Up: Gộp các module cùng chức năng, thiết kế thêm cho phong phú đầy đủ

    4. CÁC KĨ THUẬT
- Chia để trị: Chia thành các bài toán con có kích thước nhỏ hơn, giải các bài con rồi tổng hợp kết quả
  + Quan trọng nhất
  + Gồm: Phân tích thành bài toán cơ sở và Tổng hợp kết quả
- Quy hoạch động: Tạo bảng lưu tất cả các kết quả của bài toán con, khi cần thì lấy kết quả từ bảng mà không cần tính lại
- Lựa chọn thành phần ~ Tham ăn: Lựa chọn các thành phần tốt, tối ưu trước, các thành phần không tốt chọn sau
- Quay lui: Phân tích cho tới cả điểm dừng, khi không ra kết quả thì quay lại hoặc đi hướng khác
  + Nghịch đảo Ba Lan
  + Cắt tỉa Alpha-Beta

    5. MẢNG
- Mảng là tập hợp có thứ tự, số lượng phần tử xác định, truy cập cùng tên
- Mảng 1 chiều là tập hợp tuần tự phần tử cùng kiểu dữ liệu, lưu trữ trong dãy ô nhớ liên tục
  + Địa chỉ = Base + (i-1)
  + Phép toán
    -- Tạo
    -- Sắp xếp
    -- Tìm kiếm
    -- Tính toán: tbinh = cộng → chia, phsai = cộng bp → chia, dolech = bình phương
- Mảng 2 chiều (m x n ~ m dòng và n cột) là nhiều mảng 1 chiều đứng cạnh nhau
  + Lưu trữ
    -- Ưu tiên dòng: P(i,j) = Base + (i−1).n.k + (j−1).k
    -- Ưu tiên cột: P(i,j) = Base + (i−1).k + (j−1).m.k
  + Phép toán: Tạo, tìm, cộng, nhân 2 chiều với 1 chiều, nhân 2 chiều

    6. DANH SÁCH → TUYẾN TÍNH
- Là tập hợp nhiều phần tử có tính chất cấu trúc thứ tự giữa các phần tử với nhau: Nếu biết được phần tử thứ i thì sẽ biết được vị trí của phần tử thứ i+1
  + Các phần tử có thể nằm rải rác trong bộ nhớ, không liền kề nhau
  + Key là thông tin tìm kiếm
  + Kết quả tìm kiếm là vị trí
- Phép toán: Tìm, thêm, xóa, thay thế phần tử, ghép, tách, sắp xếp
  
  a. Stack = ngăn xếp (LIFO)
- Là kiểu danh sách tuyến tính mà việc thêm hay bỏ chỉ thực hiện ở 1 đầu đỉnh (Top)
  → Danh sách hạn chế
- Rỗng → Top=0, tràn → Top=n, thêm → Top+=1, xóa → Top-=1
- Lưu trữ = mảng

  b. Queue = hàng đợi (FIFO)
- Là kiểu danh sách tuyến tính mà việc thêm thực hiện ở lối sau (Rear) và xóa thực hiện ở lối trước (Front)
- Rỗng → Front = Rear
- Lưu trữ = vector
  + Theo mảng tuyến tính: Mặc định Front = Rear = 0 → Sẽ chạy lung tung trong bộ nhớ (Không tối ưu)
    -- Thêm: Rear = Rear + 1
    -- Xóa: Front = Front + 1
  + Theo nối vòng: Liền sau phần tử cuối = quay về phần tử đầu
    -- Thêm: Rear = (Rear+1) % Size
    -- Xóa: Front = (Front+1) % Size

  c. Danh sách liên kết đơn
- Mỗi phần tử lưu trữ trong 1 node, mỗi node gồm 1 số từ máy liên tiếp nhau, có thể nằm rải rác trong bộ nhớ
- Node = Data + Liên kết trỏ phần tử sau
- Phù hợp cho danh sách nhiều biến động >< Tìm kiếm sẽ lâu vì tìm tuần tự

  d. Danh sách liên kết đôi
- Các phần tử có 2 vùng liên kết
- Lptr của L và Rptr của R là Nil

    7. PHI TUYẾN
  a. Cây
- Là tập hợp hữu hạn node có quan hệ phân cấp xuất phát từ node gốc (Root = mức 1)
- Cây nhị phân
  + Mỗi node chỉ có tối đa 2 node con
  -- Số node tối đa ở mức i = 2 ^ (i-1) 
  -- Số node tối đa trên cây có chiều cao h = 2^h - 1
  + Lưu trữ
  -- Bằng mảng
      → Node đánh số từ trái sang, từ trên xuống → Node con của i là 2i và 2i + 1
      → Tốn bộ nhớ, giải thuật không hiệu quả
  -- Bằng danh sách liên kết đôi: Trường dữ liệu, trỏ LChild tới con trái, trỏ RChild tới con phải
- Quét cây nhị phân: 6 cách nhưng phổ biến 3 cách
  + LNR (trung tự)
  + NLR (tiền tự)
  + LRN (hậu tự)
- Cây nhị phân tìm kiếm → Mỗi node thỏa mãn: node trái nhỏ hơn, node phải lớn hơn
- Cây nhị phân cân đối AVL
  + Chiều cao 2 cây con tương ứng với mỗi node chênh nhau 1 đơn vị
    → Cây nhị phân đầy đủ là cây AVL
  + Hệ số cân đối
    -- 00 → 2 cây con cùng chiều cao
    -- 01 → Cây con phải cao hơn
    -- 10 → Cây con trái cao hơn

  b. Đồ thị
- Đồ thị có hướng
  + Tập hợp hữu hạn phần tử node hay đỉnh, cùng tập hợp hữu hạn cạnh có hướng nối các đỉnh
  + Biểu diễn
    -- Ma trận kề → Tốn nhiều bộ nhớ
        Ma trận vuông bậc n
        Hàng i cột j = đường từ i đến j
    -- Danh sách kề
        Mảng con trỏ, mỗi con trỏ cho 1 node trong đồ thị
        Mỗi phần tử trỏ đến đầu danh sách liên kết của node kề (dữ liệu node + liên kết chỉ node sau)
- Đồ thị vô hướng
  + Tập hợp hữu hạn phần tử node hay đỉnh, cùng tập hợp hữu hạn cạnh nối các đỉnh
  + Biểu diễn
    -- Ma trận kề = ma trận đối xứng → Cho hàng i cột j sẽ biết đường từ j đến i 
    -- Danh sách kề → Thông tin lưu trữ bị thừa
    -- Danh sách cạnh: Cạnh biểu diễn bằng 1 nhóm 4 ô (2 ô trên là node nối bởi cạnh, 2 ô dưới chỉ đến cạnh khác)
- Cây là trường hợp đặc biệt của đồ thị ~ Đồ thị có hướng
  → Quét cây
  + Ưu tiên chiều rộng (BFS) = Thăm các node lần lượt theo mức từ trên xuống
  + Ưu tiên chiều sâu (DFS) = Thăm từng node con theo chiều sâu từ trái qua, từ trên xuống

    8. SẮP XẾP → Chỉ số chạy từ 1 đến n
- Đánh giá giải thuật
  + Vùng nhớ nhỏ = Sử dụng hữu hiệu vùng nhớ phần tử + Hạn chế sử dụng vùng nhớ tạm
  + Thời gian nhanh = Số lần so sánh (C) + Số lần đổi chỗ (M)
- Phân loại
  + Xen vào = Nổi bọt, chèn, chọn → Độ phức tạp O(n^2)
  + Chọn lựa = Chèn, giảm độ tăng
  + Đổi chỗ = Chọn, nhanh, heap → Độ phức tạp O(n^2)
- Sắp xếp theo khóa
  + Trường khóa là trường mà ta muốn sắp xếp theo
  + Bảng khóa là bảng phụ chỉ chứa trường khóa và con trỏ tới bản ghi tương ứng trong bảng gốc
    → Sắp xếp trong bảng khóa, truy nhập bản ghi theo thứ tự qua con trỏ → Tiết kiệm bộ nhớ

  a. Nổi bọt (cải tiến thành Shaker) ~ So sánh liên tiếp → Chậm nhất 
- Tại bước i, duyệt từ đầu đến cuối, nếu A[j] > A[j+1] thì đổi chỗ, lặp lại đến khi không xảy ra đổi chỗ
- Độ phức tạp = O(n^2) 

  b. Chọn ~ MinPos → Pp trực tiếp tốt nhất
- Tại bước i, chọn phần tử nhỏ nhất A[i] đến A[n] để đổi chỗ với A[i]
   → Sau mỗi bước thì min đẩy lên đầu
- Độ phức tạp = O(n^2)

  c. Nhanh → Nhanh và tốt nhất
- Chọn ngẫu nhiên A[i] (biên ~ thường lấy phần tử cuối) để chia dãy thành 3 phần > < = A[i], lặp lại đến khi cụm > và < chỉ còn 1 phần tử
- Độ phức tạp
  + O(n.logn) (trung bình)
  + O(n^2) (tệ nhất khi biên là min max)

  d. Đếm
- Đếm số phần tử có khóa nhỏ hơn hoặc bằng A[i]
  → Có m phần tử thỏa mãn thì vị trí A[i] là m+1
- Độ phức tạp = O(n + k) với k=A[max]

  e. Chèn
- Tại bước i, so sánh A[i] (cầm canh) với lần lượt A[i-1] về A[1] để tìm vị trí chèn vào
- Độ phức tạp = O(n^2) (n-1 vòng)

  f. Trộn
- Liên tục chia đôi dãy cho đến khi chỉ còn 1 phần tử mỗi dãy, trộn lại và sắp xếp
- Độ phức tạp = O(n.logn)

9. Tìm kiếm
- Khóa tìm kiếm (đối trị) là giá trị cần tìm kiếm ~ X
- Tuần tự (đơn giản, cổ điển)
  + Lần lượt so sánh khóa với X cho đến khi tìm được hoặc hết bảng
  + Độ phức tạp = O(n)
- Nhị phân (thông dụng)
  + Sắp xếp, lấy khóa [(k+m)/2] so sánh với X, xác định đoạn mới cho đến khi tìm được hoặc còn 1 phần tử
    -- Ban đầu k=1, m=n
    -- Khóa < X → k=i, m=n
    -- Khóa > X → k=1, m=i-1
  + Độ phức tạp = O(log(2)n)
- Dựa vào giá trị khóa: Bằng quy tắc, biến đổi bản ghi thành địa chỉ tương đối để lưu trữ và tìm kiếm
  → Hàm băm
